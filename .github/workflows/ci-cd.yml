name: Build, Test and Deploy
# Controls when the action will run. Triggers the workflow on push
on:
  push:
    branches:
      - "*"
# A workflow run is made up of one or more jobs that can run sequentially or parallel
jobs:
  # The first job in this workflow is named build-image
  build:
    # Type of runner that the job wll run on
    runs-on: ubuntu-latest
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - name: Step 1 - Checkout Github Repository
        uses: actions/checkout@v3
      # Add parallel builds for multi platform support
      - name: Step 2 - Set up QEMU
        uses: docker/setup-qemu-action@v2
      # The BuildKit Cache
      - name: Step 3 - Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      # Push to Docker Engine
      - name: Step 4 - Build Image & Export to Docker Engine
        uses: docker/build-push-action@v2
        with:
          push: false
          tags: nblocks-ts-client:latest
          target: test
          outputs: type=docker,dest=/tmp/nblocks-ts-client.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
      # Upload Docker Image Artifact
      - name: Step 5 - Upload Artifact
        uses: actions/upload-artifact@v3
        with:
          name: nblocks-ts-client
          path: /tmp/nblocks-ts-client.tar
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      # Checkout Github Repository
      - name: Step 1 - Checkout Github Repository
        uses: actions/checkout@v3
      # Add parallel builds for multi platform support
      - name: Step 2 - Set up QEMU
        uses: docker/setup-qemu-action@v2
      # The BuildKit Cache
      - name: Step 3 - Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      # Download the Artifact Image
      - name: Step 4 - Downloading Image Artifact
        uses: actions/download-artifact@v3
        with:
          name: nblocks-ts-client
          path: /tmp
      # For Unit tests (npm test, etc)
      - name: Step 5 - Unit Testing in Docker
        run: |
          docker load --input /tmp/nblocks-ts-client.tar
          docker run --rm nblocks-ts-client:latest npm run test
  deploy:
    needs: [build, test]
    if: ${{ github.ref_name == 'master' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      # Checkout Github Repository
      - name: Step 1 - Checkout Github Repository
        uses: actions/checkout@v3
        # Add parallel builds for multi platform support
      - name: Step 2 - Set up QEMU
        uses: docker/setup-qemu-action@v2
      # The BuildKit Cache
      - name: Step 3 - Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      # If push and to master, then build the image and run it with npm run npm-publish
      - name: Step 7 - Build Image and Export to Docker Engine
        uses: docker/build-push-action@v2
        with:
          push: false
          load: true
          tags: ${{ github.run_id }}
          target: test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
      # Run container using the image aboce and run the publish script
      - name: Step 8 - Publish package to the npm
        run: |
          docker run -e NPM_TOKEN=${{ secrets.NPM_TOKEN }} --rm ${{ github.run_id }} /bin/bash -c "sh ./publish.sh; npm run npm-publish"
